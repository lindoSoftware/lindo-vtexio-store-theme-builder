"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectResponseInfoOnSpan = exports.injectRequestInfoOnSpan = void 0;
const buildFullPath_1 = __importDefault(require("../../../../../../utils/buildFullPath"));
const constants_1 = require("../../../../../../constants");
const Tags_1 = require("../../../../../../tracing/Tags");
const utils_1 = require("../../../../../../tracing/utils");
const injectRequestInfoOnSpan = (span, http, config) => {
    span === null || span === void 0 ? void 0 : span.addTags({
        [Tags_1.OpentracingTags.SPAN_KIND]: Tags_1.OpentracingTags.SPAN_KIND_RPC_CLIENT,
        [Tags_1.OpentracingTags.HTTP_METHOD]: config.method,
        [Tags_1.OpentracingTags.HTTP_URL]: (0, buildFullPath_1.default)(config.baseURL, http.getUri(config)),
    });
    span === null || span === void 0 ? void 0 : span.log({ 'request-headers': (0, utils_1.cloneAndSanitizeHeaders)(config.headers) });
};
exports.injectRequestInfoOnSpan = injectRequestInfoOnSpan;
// Response may be undefined in case of client timeout, invalid URL, ...
const injectResponseInfoOnSpan = (span, response) => {
    if (!response) {
        span === null || span === void 0 ? void 0 : span.setTag("http.no_response" /* CustomHttpTags.HTTP_NO_RESPONSE */, 'true');
        return;
    }
    span === null || span === void 0 ? void 0 : span.log({ 'response-headers': (0, utils_1.cloneAndSanitizeHeaders)(response.headers) });
    span === null || span === void 0 ? void 0 : span.setTag(Tags_1.OpentracingTags.HTTP_STATUS_CODE, response.status);
    if (response.headers[constants_1.ROUTER_CACHE_HEADER]) {
        span === null || span === void 0 ? void 0 : span.setTag("http.cache.router" /* CustomHttpTags.HTTP_ROUTER_CACHE_RESULT */, response.headers[constants_1.ROUTER_CACHE_HEADER]);
    }
};
exports.injectResponseInfoOnSpan = injectResponseInfoOnSpan;
