/// <reference types="node" />
/// <reference types="node" />
import { IncomingMessage } from 'http';
import { Readable } from 'stream';
import { Logger } from './../../service/logger/logger';
import { InstanceOptions, IOResponse, RequestTracingConfig } from '../../HttpClient';
import { BucketMetadata, FileListItem, VBaseSaveResponse } from '../../responses';
import { IOContext } from '../../service/worker/runtime/typings';
import { InfraClient } from './InfraClient';
export declare class VBase extends InfraClient {
    constructor(context: IOContext, options?: InstanceOptions);
    getBucket: (bucket: string, tracingConfig?: RequestTracingConfig) => Promise<BucketMetadata>;
    resetBucket: (bucket: string, tracingConfig?: RequestTracingConfig) => Promise<IOResponse<void>>;
    listFiles: (bucket: string, opts?: string | VBaseOptions, tracingConfig?: RequestTracingConfig) => Promise<BucketFileList>;
    getFile: (bucket: string, path: string, tracingConfig?: RequestTracingConfig) => Promise<{
        data: Buffer;
        headers: any;
    }>;
    getJSON: <T>(bucket: string, path: string, nullIfNotFound?: boolean, conflictsResolver?: ConflictsResolver<T> | undefined, tracingConfig?: RequestTracingConfig) => Promise<T>;
    getRawJSON: <T>(bucket: string, path: string, nullIfNotFound?: boolean, conflictsResolver?: ConflictsResolver<T> | undefined, tracingConfig?: RequestTracingConfig) => Promise<IOResponse<T>>;
    getFileStream: (bucket: string, path: string, tracingConfig?: RequestTracingConfig) => Promise<IncomingMessage>;
    saveFile: (bucket: string, path: string, stream: Readable, gzip?: boolean, ttl?: number, tracingConfig?: RequestTracingConfig, ifMatch?: string) => Promise<void>;
    getFileMetadata: (bucket: string, path: string, tracingConfig?: RequestTracingConfig) => Promise<IOResponse<void>>;
    saveJSON: <T>(bucket: string, path: string, data: T, tracingConfig?: RequestTracingConfig, ifMatch?: string) => Promise<VBaseSaveResponse>;
    saveZippedContent: (bucket: string, path: string, stream: Readable, tracingConfig?: RequestTracingConfig, ifMatch?: string) => Promise<void>;
    deleteFile: (bucket: string, path: string, tracingConfig?: RequestTracingConfig, ifMatch?: string) => Promise<IOResponse<void>>;
    getConflicts: <T>(bucket: string, tracingConfig?: RequestTracingConfig) => Promise<T>;
    resolveConflict: <T>(bucket: string, path: string, content: any, tracingConfig?: RequestTracingConfig) => Promise<T>;
    private saveContent;
}
export interface BucketFileList {
    data: FileListItem[];
    next: string;
    smartCacheHeaders: any;
}
export interface VBaseOptions {
    prefix?: string;
    next?: string;
    limit?: number;
}
export interface VBaseSaveOptions {
    gzip?: boolean;
    unzip?: boolean;
    ttl?: number;
}
export interface VBaseConflictData {
    path: string;
    base: VBaseConflict;
    master: VBaseConflict;
    mine: VBaseConflict;
}
export interface VBaseConflict {
    contentOmitted: boolean;
    deleted: boolean;
    mimeType: string;
    parsedContent?: any;
    content: string;
}
export interface ConflictsResolver<T> {
    resolve: (logger?: Logger) => T | Promise<T>;
}
