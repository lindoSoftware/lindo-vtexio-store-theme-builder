"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const constants_1 = require("../../constants");
const error_1 = require("../../utils/error");
const log_1 = require("../../utils/log");
const loggerTypes_1 = require("./loggerTypes");
const client_1 = require("./client");
const app = constants_1.APP.ID;
const EMPTY_MESSAGE = 'Logger.log was called with null or undefined message';
class Logger {
    constructor(ctx) {
        this.logClient = undefined;
        this.clientInitPromise = undefined;
        this.debug = (message) => this.log(message, loggerTypes_1.LogLevel.Debug);
        this.info = (message) => this.log(message, loggerTypes_1.LogLevel.Info);
        this.warn = (warning) => this.log(warning, loggerTypes_1.LogLevel.Warn);
        this.error = (error) => this.log(error, loggerTypes_1.LogLevel.Error);
        this.log = (message, level) => {
            var _a;
            const data = message ? (0, error_1.cleanError)(message) : EMPTY_MESSAGE;
            (0, log_1.cleanLog)(data);
            /* tslint:disable:object-literal-sort-keys */
            const inflatedLog = {
                __VTEX_IO_LOG: true,
                level,
                app,
                account: this.account,
                workspace: this.workspace,
                production: this.production,
                data,
                operationId: this.operationId,
                requestId: this.requestId,
                ...(((_a = this.tracingState) === null || _a === void 0 ? void 0 : _a.isTraceSampled) ? { traceId: this.tracingState.traceId } : null),
            };
            // Mark third-party apps logs to send to skidder
            if (constants_1.APP.IS_THIRD_PARTY()) {
                Object.assign(inflatedLog, {
                    '__SKIDDER_TOPIC_1': `skidder.vendor.${constants_1.APP.VENDOR}`,
                    '__SKIDDER_TOPIC_2': `skidder.app.${constants_1.APP.VENDOR}.${constants_1.APP.NAME}`,
                });
            }
            if (this.logClient) {
                try {
                    let logMessage = typeof data === 'string' ? data : JSON.stringify(data);
                    switch (level) {
                        case loggerTypes_1.LogLevel.Debug:
                            this.logClient.debug(logMessage, inflatedLog);
                            break;
                        case loggerTypes_1.LogLevel.Info:
                            this.logClient.info(logMessage, inflatedLog);
                            break;
                        case loggerTypes_1.LogLevel.Warn:
                            this.logClient.warn(logMessage, inflatedLog);
                            break;
                        case loggerTypes_1.LogLevel.Error:
                            this.logClient.error(logMessage, inflatedLog);
                            break;
                        default:
                            this.logClient.info(logMessage, inflatedLog);
                    }
                }
                catch (e) {
                    console.error('Error using diagnostics client for logging:', e);
                }
            }
            console.log(JSON.stringify(inflatedLog));
        };
        this.account = ctx.account;
        this.workspace = ctx.workspace;
        this.requestId = ctx.requestId;
        this.operationId = ctx.operationId;
        this.production = ctx.production;
        if (ctx.tracer) {
            this.tracingState = {
                isTraceSampled: ctx.tracer.isTraceSampled,
                traceId: ctx.tracer.traceId,
            };
        }
        this.initLogClient();
    }
    initLogClient() {
        if (this.clientInitPromise) {
            return this.clientInitPromise;
        }
        this.clientInitPromise = (async () => {
            try {
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Log client initialization timeout')), constants_1.LOG_CLIENT_INIT_TIMEOUT_MS);
                });
                this.logClient = await Promise.race([
                    (0, client_1.getLogClient)(),
                    timeoutPromise
                ]);
                return this.logClient;
            }
            catch (error) {
                console.error('Failed to initialize log client:', error);
                return undefined;
            }
        })();
        return this.clientInitPromise;
    }
}
exports.Logger = Logger;
