"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addOtelRequestMetricsMiddleware = void 0;
const stream_1 = require("stream");
const utils_1 = require("../../utils");
const metrics_1 = require("./metrics");
const INSTRUMENTS_INITIALIZATION_TIMEOUT = 500;
const addOtelRequestMetricsMiddleware = () => {
    let instruments;
    const tryGetInstruments = async (ctx) => {
        try {
            return await Promise.race([
                (0, metrics_1.getOtelInstruments)(),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout waiting for OpenTelemetry instruments initialization')), INSTRUMENTS_INITIALIZATION_TIMEOUT))
            ]);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.warn(`OpenTelemetry instruments not ready for request ${ctx.requestHandlerName}: ${errorMessage}`);
            return undefined;
        }
    };
    return async function addOtelRequestMetrics(ctx, next) {
        instruments = instruments ? instruments : await tryGetInstruments(ctx);
        if (!instruments) {
            await next();
            return;
        }
        const start = process.hrtime();
        instruments.concurrentRequests.add(1);
        ctx.req.once('aborted', () => {
            if (instruments) {
                instruments.abortedRequests.add(1, { ["handler" /* RequestsMetricLabels.REQUEST_HANDLER */]: ctx.requestHandlerName });
            }
        });
        let responseClosed = false;
        ctx.res.once('close', () => (responseClosed = true));
        try {
            await next();
        }
        finally {
            const responseLength = ctx.response.length;
            if (responseLength && instruments) {
                instruments.responseSizes.record(responseLength, { ["handler" /* RequestsMetricLabels.REQUEST_HANDLER */]: ctx.requestHandlerName });
            }
            if (instruments) {
                instruments.totalRequests.add(1, {
                    ["handler" /* RequestsMetricLabels.REQUEST_HANDLER */]: ctx.requestHandlerName,
                    ["status_code" /* RequestsMetricLabels.STATUS_CODE */]: ctx.response.status,
                });
            }
            const onResFinished = () => {
                if (instruments) {
                    instruments.requestTimings.record((0, utils_1.hrToMillisFloat)(process.hrtime(start)), {
                        ["handler" /* RequestsMetricLabels.REQUEST_HANDLER */]: ctx.requestHandlerName,
                    });
                    instruments.concurrentRequests.subtract(1);
                }
            };
            if (responseClosed) {
                onResFinished();
            }
            else {
                (0, stream_1.finished)(ctx.res, onResFinished);
            }
        }
    };
};
exports.addOtelRequestMetricsMiddleware = addOtelRequestMetricsMiddleware;
