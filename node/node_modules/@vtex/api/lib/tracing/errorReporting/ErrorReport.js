"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorReport = void 0;
const node_error_report_1 = require("@vtex/node-error-report");
const __1 = require("..");
const utils_1 = require("../utils");
class ErrorReport extends node_error_report_1.ErrorReportBase {
    /**
     * Create a new ErrorReport wrapping args.originalError
     *
     * In case the args.originalError argument is already an ErrorReport
     * instance, then ErrorReport.create just returns it. If it's not,
     * it returns a new ErrorReport wrapping the error. This way you can
     * use ErrorReport.create on a catchAll, e.g.:
     *
     * ```
     * try {
     *   await next()
     * } catch(err) {
     *   ErrorReport.create({ originalError: err }).injectOnSpan(span)
     * }
     * ```
     *
     * More docs on the ErrorReport available on: https://github.com/vtex/node-error-report
     */
    static create(args) {
        if (args.originalError instanceof ErrorReport) {
            return args.originalError;
        }
        return new ErrorReport((0, node_error_report_1.createErrorReportBaseArgs)(args));
    }
    /**
     * Inject information about the error wrapped by this ErrorReport
     * instance on the provided Span. If a logger is provided and the
     * span is part of a **sampled** trace, then the error will be logged.
     */
    injectOnSpan(span, logger) {
        var _a, _b, _c, _d;
        span === null || span === void 0 ? void 0 : span.setTag(__1.TracingTags.ERROR, 'true');
        const indexedLogs = {
            ["error.kind" /* ErrorReportLogFields.ERROR_KIND */]: this.kind,
            ["error.id" /* ErrorReportLogFields.ERROR_ID */]: this.metadata.errorId,
        };
        if ((0, node_error_report_1.isRequestInfo)(this.parsedInfo) &&
            this.parsedInfo.response &&
            (0, node_error_report_1.isInfraErrorData)((_a = this.parsedInfo.response) === null || _a === void 0 ? void 0 : _a.data)) {
            indexedLogs["error.server.code" /* ErrorReportLogFields.ERROR_SERVER_CODE */] = this.parsedInfo.response.data.code;
            indexedLogs["error.server.request_id" /* ErrorReportLogFields.ERROR_SERVER_REQUEST_ID */] = this.parsedInfo.response.data.requestId;
        }
        const serializableError = this.toObject();
        span === null || span === void 0 ? void 0 : span.log({
            event: 'error',
            ...indexedLogs,
            ["error.message" /* ErrorReportLogFields.ERROR_MESSAGE */]: serializableError.message,
            ["error.metadata.metrics.InstantiationTime" /* ErrorReportLogFields.ERROR_METADATA_METRICS_INSTANTIATION_TIME */]: (_b = serializableError.metadata) === null || _b === void 0 ? void 0 : _b.reportCount,
            ["error.metadata.reportCount" /* ErrorReportLogFields.ERROR_METADATA_REPORT_COUNT */]: (_d = (_c = serializableError.metadata) === null || _c === void 0 ? void 0 : _c.metrics) === null || _d === void 0 ? void 0 : _d.instantiationTime,
            ["error.stack" /* ErrorReportLogFields.ERROR_STACK */]: serializableError.stack,
            ["error.code" /* ErrorReportLogFields.ERROR_CODE */]: serializableError.code,
        });
        if (logger && this.shouldLogToSplunk(span)) {
            logger.error(serializableError);
            this.markErrorAsReported();
        }
        return this;
    }
    shouldLogToSplunk(span) {
        var _a;
        return !this.isErrorReported() && ((_a = (0, utils_1.getTraceInfo)(span)) === null || _a === void 0 ? void 0 : _a.isSampled);
    }
}
exports.ErrorReport = ErrorReport;
