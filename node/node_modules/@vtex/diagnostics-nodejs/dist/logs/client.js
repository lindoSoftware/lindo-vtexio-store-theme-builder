"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NewClient = exports.LoggerClientImpl = void 0;
const api_logs_1 = require("@opentelemetry/api-logs");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const exporters_1 = require("../exporters");
const utils_1 = require("../utils");
class LoggerClientImpl {
    constructor(provider, clientName, config) {
        this.provider = provider;
        this.logger = this.provider.getLogger(config.loggerName || 'diagnostics-default-logger', config.version || "1.0.0");
        if (config.setGlobalProvider) {
            api_logs_1.logs.setGlobalLoggerProvider(this.provider);
        }
    }
    getProvider() {
        return this.provider;
    }
    getLogger(name) {
        return this.provider.getLogger(name);
    }
    log(severityNumber, message, attributes) {
        try {
            this.logger.emit({
                severityNumber,
                body: message,
                attributes: attributes || {}
            });
        }
        catch (error) {
            console.error('Error emitting log:', error);
        }
    }
    debug(message, attributes) {
        this.log(api_logs_1.SeverityNumber.DEBUG, message, attributes);
    }
    info(message, attributes) {
        this.log(api_logs_1.SeverityNumber.INFO, message, attributes);
    }
    warn(message, attributes) {
        this.log(api_logs_1.SeverityNumber.WARN, message, attributes);
    }
    error(message, attributes) {
        this.log(api_logs_1.SeverityNumber.ERROR, message, attributes);
    }
    fatal(message, attributes) {
        this.log(api_logs_1.SeverityNumber.FATAL, message, attributes);
    }
    async shutdown() {
        try {
            await this.provider?.shutdown();
        }
        catch (error) {
            throw error;
        }
    }
}
exports.LoggerClientImpl = LoggerClientImpl;
const NewClient = async (config, serviceName, clientName) => {
    if (!config.exporter) {
        const stdoutConfig = (0, exporters_1.CreateLogsExporterConfig)({ endpoint: 'stdout' });
        config.exporter = (0, exporters_1.CreateExporter)(stdoutConfig, 'stdout');
    }
    await config.exporter.initialize();
    const resource = config.resource || (0, utils_1.createResource)({
        [semantic_conventions_1.ATTR_SERVICE_NAME]: serviceName,
    });
    const provider = new sdk_logs_1.LoggerProvider({
        resource: resource
    });
    const logProcessor = config.exporter.logProcessor();
    if (logProcessor) {
        provider.addLogRecordProcessor(logProcessor);
    }
    else {
        console.error("Log processor is not available on the exporter after initialization.");
    }
    return new LoggerClientImpl(provider, clientName, config);
};
exports.NewClient = NewClient;
//# sourceMappingURL=client.js.map