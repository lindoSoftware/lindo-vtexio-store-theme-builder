"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractHeadersFromSpan = extractHeadersFromSpan;
exports.extractStatusCodeFromSpan = extractStatusCodeFromSpan;
exports.enhanceWithHTTPData = enhanceWithHTTPData;
exports.enhanceWithVTEXData = enhanceWithVTEXData;
const api_1 = require("@opentelemetry/api");
const constants_1 = require("./constants");
function extractHeadersFromSpan(span) {
    const headers = {};
    const attributes = span.attributes;
    for (const [key, value] of Object.entries(attributes)) {
        if (key.startsWith('http.request.header.')) {
            const headerKey = key.substring('http.request.header.'.length).toLowerCase();
            headers[headerKey] = String(value);
        }
        else if (key.startsWith('http.')) {
            headers[key.toLowerCase()] = String(value);
        }
    }
    return headers;
}
function extractStatusCodeFromSpan(span) {
    const attributes = span.attributes;
    const statusCode = attributes[constants_1.AttributeKeys.HTTP_STATUS_CODE];
    if (typeof statusCode === 'number') {
        return statusCode;
    }
    if (typeof statusCode === 'string') {
        const parsed = parseInt(statusCode, 10);
        if (!isNaN(parsed)) {
            return parsed;
        }
    }
    return 200;
}
function enhanceWithHTTPData(span, headers, statusCode) {
    if (headers['http.method']) {
        span.setAttribute(constants_1.AttributeKeys.HTTP_METHOD, headers['http.method']);
    }
    if (headers['http.url']) {
        span.setAttribute(constants_1.AttributeKeys.HTTP_URL, headers['http.url']);
    }
    if (headers['http.route']) {
        span.setAttribute(constants_1.AttributeKeys.HTTP_ROUTE, headers['http.route']);
    }
    const forwardedFor = headers[constants_1.HeaderKeys.FORWARDED_FOR.toLowerCase()];
    if (forwardedFor) {
        const clientIP = forwardedFor.split(',')[0].trim();
        if (clientIP) {
            span.setAttribute(constants_1.AttributeKeys.HTTP_CLIENT_IP, clientIP);
        }
    }
    if (headers['user-agent']) {
        span.setAttribute(constants_1.AttributeKeys.HTTP_USER_AGENT, headers['user-agent']);
    }
    if (headers['host']) {
        const hostParts = headers['host'].split(':');
        if (hostParts.length === 2 && (hostParts[1] === '80' || hostParts[1] === '443')) {
            span.setAttribute(constants_1.AttributeKeys.HTTP_HOST, hostParts[0]);
        }
        else {
            span.setAttribute(constants_1.AttributeKeys.HTTP_HOST, headers['host']);
        }
    }
    span.setAttribute(constants_1.AttributeKeys.HTTP_STATUS_CODE, statusCode);
    if (statusCode >= 500) {
        span.setAttribute(constants_1.AttributeKeys.ERROR, true);
        span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: `HTTP ${statusCode}`
        });
    }
}
function enhanceWithVTEXData(span, headers) {
    let vtexUserAgent = 'unknown';
    const userAgentHeaders = [
        constants_1.HeaderKeys.VTEX_USER_AGENT.toLowerCase(),
        constants_1.HeaderKeys.VTEX_IO_CALLER.toLowerCase(),
        constants_1.HeaderKeys.VTEX_APP_SERVICE.toLowerCase()
    ];
    for (const header of userAgentHeaders) {
        if (headers[header]) {
            vtexUserAgent = headers[header];
            break;
        }
    }
    span.setAttribute(constants_1.AttributeKeys.VTEX_USER_AGENT, vtexUserAgent);
    let username = headers[constants_1.HeaderKeys.VTEX_APP_KEY.toLowerCase()] || 'anonymous';
    span.setAttribute(constants_1.AttributeKeys.VTEX_IDENTITY_USERNAME, username);
    span.setAttribute(constants_1.AttributeKeys.VTEX_IDENTITY_USER_ID, username);
    const retryCount = headers[constants_1.HeaderKeys.VTEX_RETRY_COUNT.toLowerCase()];
    if (retryCount) {
        span.setAttribute(constants_1.AttributeKeys.VTEX_RETRY_COUNT, retryCount);
    }
}
//# sourceMappingURL=utils.js.map