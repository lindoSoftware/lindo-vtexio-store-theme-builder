"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedSampler = void 0;
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const traces_1 = require("../../types/traces");
const metadata_1 = require("./metadata");
class ComposedSampler {
    constructor(mode, samplers) {
        this.samplers = samplers;
        this.mode = mode;
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        const metadata = (0, metadata_1.newSamplerMetadata)('composed');
        metadata.addExtra('mode', this.mode);
        metadata.addExtra('samplers_count', this.samplers.length);
        if (this.samplers.length === 0) {
            return {
                decision: sdk_trace_base_1.SamplingDecision.NOT_RECORD,
                attributes: metadata
                    .setDecision(sdk_trace_base_1.SamplingDecision.NOT_RECORD, 'no_samplers')
                    .setRate(0.0)
                    .toAttributes()
            };
        }
        let combinedAttributes = {};
        const evaluatedSamplers = [];
        for (let i = 0; i < this.samplers.length; i++) {
            const sampler = this.samplers[i];
            const result = sampler.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            evaluatedSamplers.push(sampler.toString());
            if (result.attributes) {
                combinedAttributes = { ...combinedAttributes, ...result.attributes };
            }
            if (result.decision === sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED) {
                if (this.mode === traces_1.CompositionMode.SampleIfAny) {
                    return {
                        decision: sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED,
                        attributes: {
                            ...combinedAttributes,
                            ...metadata
                                .setDecision(sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED, `sampled_by_${sampler.toString()}`)
                                .addExtra('winning_sampler', sampler.toString())
                                .addExtra('evaluated_samplers', evaluatedSamplers.join(','))
                                .toAttributes()
                        }
                    };
                }
            }
            else {
                if (this.mode === traces_1.CompositionMode.SampleIfAll) {
                    return {
                        decision: sdk_trace_base_1.SamplingDecision.NOT_RECORD,
                        attributes: {
                            ...combinedAttributes,
                            ...metadata
                                .setDecision(sdk_trace_base_1.SamplingDecision.NOT_RECORD, `rejected_by_${sampler.toString()}`)
                                .addExtra('rejecting_sampler', sampler.toString())
                                .addExtra('evaluated_samplers', evaluatedSamplers.join(','))
                                .toAttributes()
                        }
                    };
                }
            }
        }
        const finalDecision = this.mode === traces_1.CompositionMode.SampleIfAll
            ? sdk_trace_base_1.SamplingDecision.RECORD_AND_SAMPLED
            : sdk_trace_base_1.SamplingDecision.NOT_RECORD;
        const finalReason = this.mode === traces_1.CompositionMode.SampleIfAll
            ? 'all_samplers_accepted'
            : 'no_sampler_accepted';
        return {
            decision: finalDecision,
            attributes: {
                ...combinedAttributes,
                ...metadata
                    .setDecision(finalDecision, finalReason)
                    .addExtra('evaluated_samplers', evaluatedSamplers.join(','))
                    .toAttributes()
            }
        };
    }
    toString() {
        return `ComposedSampler(mode=${this.mode})`;
    }
}
exports.ComposedSampler = ComposedSampler;
//# sourceMappingURL=composed.js.map