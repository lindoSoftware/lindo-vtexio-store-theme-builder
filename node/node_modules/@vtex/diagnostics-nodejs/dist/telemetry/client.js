"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryClient = void 0;
exports.NewTelemetryClient = NewTelemetryClient;
const tslib_1 = require("tslib");
const api_1 = require("@opentelemetry/api");
const discovery_1 = require("../discovery");
const logs = tslib_1.__importStar(require("../logs"));
const traces = tslib_1.__importStar(require("../traces"));
const metrics = tslib_1.__importStar(require("../metrics"));
const processors_1 = require("../processors");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const baggage_span_processor_1 = require("@opentelemetry/baggage-span-processor");
const config_1 = require("../config");
const exporters_1 = require("../exporters");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const sdk_trace_base_2 = require("@opentelemetry/sdk-trace-base");
const api_2 = require("@opentelemetry/api");
class TelemetryClient {
    constructor(clientName, serviceName, resource, configManager, options = {}) {
        this.resource = resource;
        this.clientName = clientName;
        this.serviceName = serviceName;
        this.configManager = configManager;
        this.options = {
            enableVtexProcessor: true,
            enableBaggageProcessor: true,
            ...options
        };
        this.noop = this.options.noop || false;
    }
    setupBaggageProcessor(processors) {
        if (this.options.enableBaggageProcessor) {
            processors.push(new baggage_span_processor_1.BaggageSpanProcessor(baggage_span_processor_1.ALLOW_ALL_BAGGAGE_KEYS));
        }
    }
    setupVtexProcessor(processors) {
        if (this.options.enableVtexProcessor) {
            processors.push(new processors_1.VtexAttrs.VtexAttributesSpanProcessor());
        }
    }
    async newLogsClient(overrides = {}) {
        if (this.noop) {
            return this.createNoopLogsClient();
        }
        const baseConfig = this.configManager.getConfig().logs || {};
        const fullConfig = {
            ...baseConfig,
            ...overrides,
            resource: this.resource,
        };
        if (!fullConfig.exporter) {
            const exporterConfigFromFile = baseConfig.exporters;
            if (exporterConfigFromFile?.mode === 'otlp' && exporterConfigFromFile.otlp?.endpoint) {
                const otlpConfig = (0, exporters_1.CreateLogsExporterConfig)({ endpoint: exporterConfigFromFile.otlp.endpoint });
                fullConfig.exporter = (0, exporters_1.CreateExporter)(otlpConfig, 'otlp');
            }
            else {
                const stdoutConfig = (0, exporters_1.CreateLogsExporterConfig)({ endpoint: 'stdout' });
                fullConfig.exporter = (0, exporters_1.CreateExporter)(stdoutConfig, 'stdout');
            }
        }
        this.logClient = await logs.NewClient(fullConfig, this.serviceName, this.clientName);
        return this.logClient;
    }
    async newTracesClient(overrides = {}) {
        if (this.noop) {
            return this.createNoopTracesClient();
        }
        if (this.traceClient) {
            return this.traceClient;
        }
        const initialDiagnosticsConfig = this.configManager.getConfig();
        const initialTracesConfig = initialDiagnosticsConfig.traces || {};
        const fullConfig = {
            ...initialTracesConfig,
            ...overrides,
            resource: this.resource,
            sampling: initialTracesConfig.sampling || overrides.sampling
        };
        if (!fullConfig.exporter) {
            const exporterConfigFromFile = initialTracesConfig.exporters;
            if (exporterConfigFromFile?.mode === 'otlp' && exporterConfigFromFile.otlp?.endpoint) {
                const otlpConfig = (0, exporters_1.CreateTracesExporterConfig)({ endpoint: exporterConfigFromFile.otlp.endpoint });
                fullConfig.exporter = (0, exporters_1.CreateExporter)(otlpConfig, 'otlp');
            }
            else {
                const stdoutConfig = (0, exporters_1.CreateTracesExporterConfig)({ endpoint: 'stdout' });
                fullConfig.exporter = (0, exporters_1.CreateExporter)(stdoutConfig, 'stdout');
            }
        }
        await fullConfig.exporter.initialize();
        const processors = [];
        this.setupBaggageProcessor(processors);
        this.setupVtexProcessor(processors);
        if (fullConfig.exporter?.traceExporter) {
            processors.push(new sdk_trace_base_1.BatchSpanProcessor(fullConfig.exporter.traceExporter(), {
                scheduledDelayMillis: initialTracesConfig.batchTimeoutMs || 5000,
                maxExportBatchSize: initialTracesConfig.maxBatchSize || 512,
                maxQueueSize: initialTracesConfig.maxQueueSize || 2048,
            }));
        }
        fullConfig.processors = processors;
        const client = await traces.NewClient(fullConfig, this.serviceName, this.clientName);
        this.traceClient = client;
        this.configManager.onConfigChange((newConfig) => {
            if (newConfig.traces && this.traceClient) {
                this.traceClient.updateTracesConfig(newConfig.traces);
            }
        });
        return this.traceClient;
    }
    async newMetricsClient(overrides = {}) {
        if (this.noop) {
            return this.createNoopMetricsClient();
        }
        const baseConfig = this.configManager.getConfig().metrics || {};
        const fullConfig = {
            ...baseConfig,
            ...overrides,
            resource: this.resource,
        };
        if (!fullConfig.exporter) {
            const exporterConfigFromFile = baseConfig.exporters;
            if (exporterConfigFromFile?.mode === 'otlp' && exporterConfigFromFile.otlp?.endpoint) {
                const otlpConfig = (0, exporters_1.CreateMetricsExporterConfig)({ endpoint: exporterConfigFromFile.otlp.endpoint });
                fullConfig.exporter = (0, exporters_1.CreateExporter)(otlpConfig, 'otlp');
            }
            else {
                const stdoutConfig = (0, exporters_1.CreateMetricsExporterConfig)({ endpoint: 'stdout' });
                fullConfig.exporter = (0, exporters_1.CreateExporter)(stdoutConfig, 'stdout');
            }
        }
        const client = await metrics.NewClient(fullConfig, this.serviceName, this.clientName);
        this.metricsClient = client;
        return client;
    }
    createNoopLogsClient() {
        // Create a noop logger provider that implements the LoggerProvider interface
        const noopProvider = {
            getLogger: () => ({
                debug: () => { },
                info: () => { },
                warn: () => { },
                error: () => { },
                fatal: () => { },
            }),
        };
        return {
            debug: () => { },
            info: () => { },
            warn: () => { },
            error: () => { },
            fatal: () => { },
            shutdown: () => Promise.resolve(),
            getProvider: () => noopProvider,
        };
    }
    createNoopTracesClient() {
        // Create a noop tracer provider that implements the NodeTracerProvider interface
        const noopProvider = {
            getTracer: () => ({
                startSpan: (name, options) => ({
                    end: () => { },
                    setAttribute: () => { },
                    setAttributes: () => { },
                    setStatus: () => { },
                    addEvent: () => { },
                    addEvents: () => { },
                    addLink: () => { },
                    addLinks: () => { },
                    updateName: () => { },
                    isRecording: () => false,
                    recordException: () => { },
                    spanContext: () => ({
                        traceId: 'noop-trace-id',
                        spanId: 'noop-span-id',
                        traceFlags: 0,
                        traceState: {},
                    }),
                }),
                startActiveSpan: () => undefined,
            }),
            register: () => { },
            _config: {},
            _registeredSpanProcessors: [],
            _tracers: new Map(),
            activeSpanProcessor: new sdk_trace_base_2.NoopSpanProcessor(),
            resource: this.resource,
            getActiveSpanProcessor: () => new sdk_trace_base_2.NoopSpanProcessor(),
            addSpanProcessor: () => { },
            forceFlush: () => Promise.resolve(),
            shutdown: () => Promise.resolve(),
        };
        return {
            startSpan: (name, options) => {
                const span = noopProvider.getTracer('noop').startSpan(name, options);
                return span;
            },
            endSpan: (span) => {
                if (span && typeof span.end === 'function') {
                    span.end();
                }
            },
            shutdown: () => Promise.resolve(),
            getProvider: () => noopProvider,
            getContext: () => ({}),
            getActiveSpan: () => undefined,
            inject: () => { },
            extract: (headers) => ({
                ...headers,
                execute: (callback) => callback(),
            }),
            getPropagator: () => ({}),
        };
    }
    createNoopMetricsClient() {
        // Create a noop meter provider that implements the MeterProvider interface
        const noopProvider = {
            getMeter: () => (0, api_2.createNoopMeter)(),
            _sharedState: {},
            _shutdown: false,
            addMetricReader: () => { },
            shutdown: () => Promise.resolve(),
            forceFlush: () => Promise.resolve(),
        };
        // Create a noop metrics client that implements the MetricsClient interface
        const noopMeter = (0, api_2.createNoopMeter)();
        return {
            meter: () => noopMeter,
            provider: () => noopProvider,
            counter: (name, opts) => ({
                add: () => { },
                increment: () => { },
            }),
            gauge: (name, opts) => ({
                add: () => { },
                set: () => { },
                subtract: () => { },
            }),
            histogram: (name, opts) => ({
                record: () => { },
            }),
            createCounter: (name, options) => ({
                add: () => { },
                increment: () => { },
            }),
            createGauge: (name, options) => ({
                add: () => { },
                set: () => { },
                subtract: () => { },
            }),
            createHistogram: (name, options) => ({
                record: () => { },
            }),
            shutdown: () => Promise.resolve(),
            getProvider: () => noopProvider,
        };
    }
    registerInstrumentations(instrumentations) {
        if (!instrumentations || instrumentations.length === 0) {
            console.warn('[TelemetryClient] No instrumentations provided for registration.');
            return;
        }
        if (!this.traceClient || !this.traceClient.getProvider()) {
            throw new Error('Trace client is not initialized. Please initialize the trace client before registering instrumentations.');
        }
        if (!this.metricsClient || !this.metricsClient.getProvider()) {
            throw new Error('Metrics client is not initialized. Please initialize the metrics client before registering instrumentations.');
        }
        if (!this.logClient || !this.logClient.getProvider()) {
            throw new Error('Log client is not initialized. Please initialize the log client before registering instrumentations.');
        }
        (0, instrumentation_1.registerInstrumentations)({
            instrumentations,
            tracerProvider: this.traceClient?.getProvider(),
            meterProvider: this.metricsClient?.getProvider(),
            loggerProvider: this.logClient?.getProvider(),
        });
    }
    getGlobalProviderInfo() {
        try {
            const globalProvider = api_1.trace.getTracerProvider();
            const isNoopProvider = globalProvider.constructor.name === 'NoopTracerProvider';
            return {
                exists: !isNoopProvider,
                provider: isNoopProvider ? undefined : globalProvider
            };
        }
        catch {
            return { exists: false };
        }
    }
}
exports.TelemetryClient = TelemetryClient;
async function NewTelemetryClient(applicationID, clientName, serviceName, options = {}) {
    if (!applicationID || typeof applicationID !== 'string' || applicationID.trim() === '') {
        throw new Error('applicationID is required and must be a non-empty string');
    }
    if (!serviceName || typeof serviceName !== 'string' || serviceName.trim() === '') {
        throw new Error('serviceName is required and must be a non-empty string');
    }
    if (options.debug) {
        const { diag, DiagConsoleLogger, DiagLogLevel } = await Promise.resolve().then(() => tslib_1.__importStar(require('@opentelemetry/api')));
        diag.setLogger(new DiagConsoleLogger(), DiagLogLevel.DEBUG);
    }
    const { enableVtexProcessor = true, vtexProcessorConfig, enableBaggageProcessor = true, noop = false, ...resourceOptions } = options;
    const resourceConfig = {
        clientName,
        serviceName,
        applicationID,
        environment: resourceOptions.environment,
        envMappings: resourceOptions.envMappings,
        customAttributesFile: resourceOptions.customAttributesFile,
        additionalAttrs: resourceOptions.additionalAttrs,
        disableCloudDetect: resourceOptions.disableCloudDetect,
        disableK8sDetect: resourceOptions.disableK8sDetect,
    };
    const resource = await (0, discovery_1.configureDefaults)(resourceConfig);
    const configManager = new config_1.ConfigManager(applicationID, serviceName, {
        configPath: options.config?.configPath,
        enableHotReload: options.config?.enableHotReload ?? true,
        pollIntervalMs: options.config?.pollIntervalMs || 15000,
    });
    await configManager.initialize();
    const clientOptions = {
        enableVtexProcessor,
        vtexProcessorConfig,
        enableBaggageProcessor,
        noop,
    };
    return new TelemetryClient(clientName, serviceName, resource, configManager, clientOptions);
}
//# sourceMappingURL=client.js.map