"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NewClient = exports.TraceClientImpl = void 0;
const api_1 = require("@opentelemetry/api");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const context_async_hooks_1 = require("@opentelemetry/context-async-hooks");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const types_1 = require("../types");
const instrumentation_1 = require("../instrumentation");
const utils_1 = require("../utils");
const composed_1 = require("../samplers/traces/composed");
const debug_1 = require("../samplers/traces/debug");
const configurable_1 = require("../samplers/traces/configurable");
class TraceClientImpl {
    constructor(config, serviceName, clientName) {
        if (!serviceName)
            throw new Error('Service name is required');
        this.standardPropagator = (0, instrumentation_1.createCompositePropagator)();
        const resource = config.resource || (0, utils_1.createResource)({ [semantic_conventions_1.ATTR_SERVICE_NAME]: serviceName });
        const initialSamplingConfig = config.sampling || {
            defaultRate: 0.1,
            parentBased: true,
            rules: []
        };
        this.configurableSampler = new configurable_1.ConfigurableSampler(initialSamplingConfig);
        const debugSampler = new debug_1.DebugSampler();
        const composedSampler = new composed_1.ComposedSampler(types_1.CompositionMode.SampleIfAny, [this.configurableSampler, debugSampler]);
        let finalSampler = composedSampler;
        if (initialSamplingConfig.parentBased !== false) {
            finalSampler = new sdk_trace_base_1.ParentBasedSampler({ root: composedSampler });
        }
        const provider = new sdk_trace_node_1.NodeTracerProvider({
            resource: resource,
            sampler: finalSampler,
            spanProcessors: config.processors,
        });
        this.tracerProvider = provider;
        if (config.setGlobalProvider !== false) {
            api_1.context.setGlobalContextManager(new context_async_hooks_1.AsyncLocalStorageContextManager());
            api_1.propagation.setGlobalPropagator(this.standardPropagator);
            api_1.trace.setGlobalTracerProvider(this.tracerProvider);
        }
        this.otelTracer = this.tracerProvider.getTracer(clientName);
        this.exporter = config.exporter;
    }
    updateTracesConfig(newConfig) {
        if (newConfig.sampling) {
            this.configurableSampler.updateConfig(newConfig.sampling);
        }
    }
    getProvider() { return this.tracerProvider; }
    startSpan(name, options) {
        const otelSpanOptions = {
            attributes: options?.attributes || {}
        };
        if (options?.kind)
            otelSpanOptions.kind = options.kind;
        if (options?.timestamp)
            otelSpanOptions.startTime = options.timestamp;
        const otelSpan = this.otelTracer.startSpan(name, otelSpanOptions, options?.parentContext);
        return otelSpan;
    }
    endSpan(span) {
        span.end();
    }
    getPropagator() {
        return this.standardPropagator;
    }
    inject(headers, ctx) {
        const propagator = this.getPropagator();
        if (propagator) {
            const contextToUse = ctx || api_1.context.active();
            propagator.inject(contextToUse, headers, {
                set: (carrier, key, value) => { carrier[key] = value; }
            });
        }
    }
    extract(headers) {
        const propagator = this.getPropagator();
        let extractedContext;
        if (propagator) {
            const activeContext = api_1.context.active();
            extractedContext = propagator.extract(activeContext, headers, {
                get: (carrier, key) => carrier[key],
                keys: (carrier) => Object.keys(carrier)
            });
        }
        else {
            extractedContext = api_1.context.active();
        }
        const enhancedContext = extractedContext;
        enhancedContext.execute = (callback) => api_1.context.with(extractedContext, callback);
        return enhancedContext;
    }
    getContext() {
        return api_1.context.active();
    }
    getActiveSpan() {
        return api_1.trace.getSpan(api_1.context.active());
    }
    async shutdown() {
        const provider = this.getProvider();
        if (provider && typeof provider.shutdown === 'function') {
            await provider.shutdown();
        }
        if (this.exporter) {
            await this.exporter.shutdown();
        }
    }
}
exports.TraceClientImpl = TraceClientImpl;
const NewClient = async (config, serviceName, clientName) => {
    if (!config.exporter) {
        const { CreateExporter, CreateTracesExporterConfig } = require('../exporters');
        const stdoutconfig = CreateTracesExporterConfig({ endpoint: 'stdout' });
        config.exporter = CreateExporter(stdoutconfig, 'stdout');
    }
    if (config.exporter) {
        await config.exporter.initialize();
    }
    return new TraceClientImpl(config, serviceName, clientName);
};
exports.NewClient = NewClient;
//# sourceMappingURL=client.js.map